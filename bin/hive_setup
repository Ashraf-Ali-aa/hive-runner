#!/usr/bin/env ruby

require 'optparse'
require 'fileutils'
require 'terminal-table'
require 'tempfile'
require 'etc'

if ARGV.length < 1
  puts "Usage:"
  puts
  puts "  hive_setup <directory>"
  exit 1
end

headless = ARGV.include?("--ni")

dir = File.expand_path('', ARGV[0])
if Dir.exists?(dir)
  if ! Dir["#{dir}/*"].empty?
    puts "Directory '#{dir}' exists and is not empty"
    exit 1
  end
else
  if File.exists?(dir)
    puts "'#{dir}' exists and is not a directory"
    exit 1
  end
  FileUtils.mkdir_p(dir)
end

def yn question
  yn = 'x'
  while yn !~ /^[yYnN]/
    print "#{question}(y/n) "
    yn = STDIN.gets.chomp
  end
  yn =~ /^[yY]/
end

def os
  if /mswin/ =~ RUBY_PLATFORM
    'Windows'
  elsif /darwin/ =~ RUBY_PLATFORM
    'Mac'
  elsif /linux/ =~ RUBY_PLATFORM
    'Linux'
  else
    'Unknown'
  end
end

def find_ruby
  ruby_versions = {}
  manager_search = {
    #'rvm' => {
    #  list: 'list',
    #  match: '/^...(ruby-\S+)/'
    #},
    'rbenv' => {
      list: 'versions',
      match: /^..(\S*)/
    },
    #'uru' => {
    #  list: 'list',
    #  match: '/^....(\S+)/'
    #},
  }
  
  manager_search.each do |m, details|
    if system("which #{m} > /dev/null 2> /dev/null")
      rubies = []
      `#{m} #{details[:list]}`.split(/\n/).each do |line|
        if line =~ details[:match] and $1 != 'system'
          rubies << $1
        end
        ruby_versions[m] = rubies
      end
    end
  end

  if ruby_versions.length == 0
    [ 'system', '' ]
  elsif ruby_versions.length == 1 && ruby_versions[ruby_versions.keys.first].length == 1
    [ruby_versions.keys.first, ruby_versions[ruby_versions.keys.first].first]
  else
    puts 'Multiple versions:'
    puts ruby_versions
    ruby_versions
  end
end

def add_modules
  # Choose options
  opt = ''
  mods = []
  while opt.upcase != 'X'
    table = Terminal::Table.new headings: ['Device', 'Module', 'Source']
    mods.each do |mod|
      table.add_row [
        mod[:device],
        mod[:name],
        mod.has_key?(:git_account) ?
          "git@github.com:#{mod[:git_account]}/#{mod[:name]}" :
          "https://rubygems.org/gems/#{mod[:name]}"
      ]
    end

    puts ''
    puts table
    puts ''
    puts '1) Add module'
    puts 'X) Continue'
    puts ''
    print "> "
    opt = STDIN.gets.chomp

    case opt
    when '1'
      mod = {}
      puts ''
      print "Module name: "
      mod[:device] = STDIN.gets.chomp
      mod[:name] = "hive-runner-#{mod[:device]}"
      puts ''

      puts "Module '#{mod[:name]}' from https://rubygems.org/gems/#{mod[:name]}"
      if yn "Correct? "
        mods << mod
      end
    end
  end

  mods
end

def setup_hive(dir, mods, daemons)
  FileUtils.mkdir_p("#{dir}/config")
  FileUtils.mkdir_p("#{dir}/log")
  FileUtils.mkdir_p("#{dir}/pids")
  FileUtils.mkdir_p("#{dir}/workspaces")

  File.open("#{dir}/config/settings.yml", 'w') do |f|
    f.puts "#{ENV['HIVE_ENVIRONMENT'] || 'test'}:"
    f.puts '  daemon_name: HIVE'
    f.puts ''
    f.puts '  controllers:'
    f.puts '    shell:'
    f.puts '      # Number of shell workers to allocate'
    f.puts '      workers: 5'
    f.puts '      # Queue for each shell worker'
    f.puts '      queues:'
    f.puts '        - bash'
    f.puts '      # Number of ports to allocate to each shell worker'
    f.puts '      port_range_size: 50'
    f.puts '      name_stub: SHELL_WORKER'
    mods.each do |m|
      f.puts "    #{m[:device]}:"
      f.puts '      # Number of ports to allocate to each #{m[:device]} worker'
      f.puts '      port_range_size: 50'
      f.puts "      name_stub: #{m[:device].upcase}_WORKER"
    end
    f.puts ''
    f.puts '  # Range of ports to be made available to workers'
    f.puts '  ports:'
    f.puts '    minimum: 4000'
    f.puts '    maximum: 5000'
    f.puts ''
    f.puts '  # Logging configuration'
    f.puts '  logging:'
    f.puts "    directory: #{dir}/log"
    f.puts "    pids: #{dir}/pids"
    f.puts '    main_filename: hive.log'
    f.puts '    main_level: INFO'
    f.puts '    worker_level: INFO'
    f.puts "    home: #{dir}/workspaces"
    f.puts '    homes_to_keep: 5'
    f.puts ''
    f.puts '  # Timing configuration'
    f.puts '  timings:'
    f.puts '    worker_loop_interval: 5'
    f.puts '    controller_loop_interval: 5'
    f.puts ''
    f.puts '  # Configuration for various network options'
    f.puts '  network:'
    f.puts '    scheduler: http://localhost:3000'
    f.puts '    #hive_mind: http://localhost:3001'
    f.puts '    # Optional cert paths:'
    f.puts '    # cert: /path/to/certificate.pem'
    f.puts '    # cafile: /path/to/certificate-authorities.pem'
    f.puts ''
    f.puts '  # Configuration for diagnostic plugins'
    f.puts '  diagnostics:'
  end

  File.open("#{dir}/Gemfile", 'w') do |f|
    f.puts "source 'https://rubygems.org/'"
    f.puts ""
    f.puts "gem 'hive-runner'"
    mods.each do |m|
      source = m.has_key?(:git_account) ? ", git: 'git@github.com:#{m[:git_account]}/#{m[:name]}'" : ''
      f.puts "gem '#{m[:name]}'#{source}"
    end
  end

  if daemons
    print "Setting up daemon ..."
    ruby_manager, ruby = find_ruby
    if ruby
      File.open("#{dir}/.ruby-version", 'w') do |rv|
        rv.write ruby
      end
    end
    puts "Manager: #{ruby_manager}"
    puts "Ruby: #{ruby}"
    if os == 'Linux'
      write_logs = '> $LOG_DIRECTORY/hive.out 2> $LOG_DIRECTORY/hive.err'
      File.open("#{dir}/start_hive.sh", 'w', 0755) do |f|
        f.write "#!/bin/bash -l\n"

#        case ruby_manager
#        when 'rvm'
#          f.write "rvm use"
#          f.write " #{ruby} #{write_logs}\n"
#        when 'rbenv'
#          File.open("#{dir}/.ruby-version", 'w') do |rv|
#            rv.write ruby
#          end
#        when 'uru'
#          f.write "uru"
#          f.write " #{ruby} #{write_logs}\n"
#        end

        f.write "if [ x$LOG_DIRECTORY == 'x' ]\n"
        f.write "then\n"
        f.write "  LOG_DIRECTORY=.\n"
        f.write "fi\n"

        f.write "cd #{dir} #{write_logs}\n"
        f.write "start_hive #{write_logs} &\n" 
        f.write "echo $!\n"
      end

      initd = Tempfile.new
      File.readlines(File.expand_path('../init.d.hived', __FILE__)).each do |line|
        line.sub! '###HIVE_HOME###', dir
        line.sub! '###RUBY_MANAGER###', ruby_manager
        line.sub! '###RUBY_VERSION###', ruby
        line.sub! '###USER###', Etc.getlogin
        initd.write line
      end
      initd.close
      system("sudo cp #{initd.path} /etc/init.d/hived")
      system("sudo chmod 755 /etc/init.d/hived")
    else
      print "FAILED\n"
      puts "  Cannot set up daemons for '#{os}'"
    end
  end

  print "Executing 'bundle install' ... "
  Dir.chdir dir
  if system("bundle install > bundle_install.out 2>&1")
    print "SUCCESS\n"
    File.delete('bundle_install.out')
  else
    print "FAILED\n"
    puts "See #{dir}/bundle_install.out for details"
    exit
  end

  puts ''
  puts 'Configuration required:'
  puts
  puts '  * Add to config/settings.yml'
  puts '      - scheduler'
  puts '      - devicedb'
  puts '      - cert'
  puts '      - cafile'
  if mods.length > 0
    puts '  * Configure these modules in config/settings.yml'
    mods.each do |m|
      puts "      - #{m[:device]}"
    end
  end
  puts '  * Add to ~/.bashrc'
  puts "      - export HIVE_CONFIG=#{dir}/config"
end

mods = []
mods = add_modules unless headless

puts
puts "Operating System: #{os}"
daemons = false
if os != 'Unknown' && yn("Start daemon on boot? ")
  daemons = true
end

setup_hive(dir, mods, daemons)
